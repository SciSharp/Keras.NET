namespace Keras.Layers
{
    using System.Collections.Generic;
    using Numpy;

    /// <summary>
    /// Input() is used to instantiate a Keras tensor.   A Keras tensor is a tensor object from the underlying backend(Theano, TensorFlow or CNTK), which we augment with certain attributes that allow us to build a Keras model just by knowing the inputs and outputs of the model.
    ///  For instance, if a, b and c are Keras tensors, it becomes possible to do: model = Model(input =[a, b], output = c)
    ///   The added Keras attributes are: _keras_shape: Integer shape tuple propagated via Keras-side shape inference._keras_history: Last layer applied to the tensor. the entire layer graph is retrievable from that layer, recursively.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Input : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Input"/> class.
        /// </summary>
        /// <param name="shape">A shape tuple (integer), not including the batch size. For instance, shape=(32,) indicates that the expected input will be batches of 32-dimensional vectors.</param>
        /// <param name="batch_shape">A shape tuple (integer), including the batch size. For instance, batch_shape=(10, 32) indicates that the expected input will be batches of 10 32-dimensional vectors.  batch_shape=(None, 32) indicates batches of an arbitrary number of 32-dimensional vectors.</param>
        /// <param name="name">An optional name string for the layer. Should be unique in a model (do not reuse the same name twice). It will be autogenerated if it isn't provided.</param>
        /// <param name="dtype">The data type expected by the input, as a string (float32, float64, int32...)</param>
        /// <param name="sparse"> A boolean specifying whether the placeholder to be created is sparse.</param>
        /// <param name="tensor">Optional existing tensor to wrap into the Input layer. If set, the layer will not create a placeholder tensor.</param>
        public Input(Shape shape, Shape batch_shape = null, string name = "", string dtype = "float32", bool sparse = false, NDarray tensor = null)
        {
            this["shape"] = shape;
            this["batch_shape"] = batch_shape;
            this["name"] = name;
            this["dtype"] = dtype;
            this["sparse"] = sparse;
            this["tensor"] = tensor;

            PyInstance = Instance.keras.layers.Input;
            Init();
        }
    }

    /// <summary>
    /// Just your regular densely-connected NN layer.
    /// Dense implements the operation: output = activation(dot(input, kernel) + bias) where activation is the element-wise activation function passed as the activation argument, kernel is a weights matrix created by the layer, and bias is a bias vector created by the layer(only applicable if use_bias is True).
    /// Note: if the input to the layer has a rank greater than 2, then it is flattened prior to the initial dot product with kernel.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Dense : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Dense"/> class.
        /// </summary>
        /// <param name="units"> Positive integer, dimensionality of the output space.</param>
        /// <param name="activation"> Activation function to use (see activations). If you don't specify anything, no activation is applied (ie. "linear" activation: a(x) = x).</param>
        /// <param name="use_bias"> Boolean, whether the layer uses a bias vector.</param>
        /// <param name="kernel_initializer"> Initializer for the kernel weights matrix (see initializers).</param>
        /// <param name="bias_initializer"> Initializer for the bias vector (see initializers).</param>
        /// <param name="kernel_regularizer"> Regularizer function applied to the kernel weights matrix (see regularizer).</param>
        /// <param name="bias_regularizer"> Regularizer function applied to the bias vector (see regularizer).</param>
        /// <param name="activity_regularizer"> Regularizer function applied to the output of the layer (its "activation"). (see regularizer).</param>
        /// <param name="kernel_constraint"> Constraint function applied to the kernel weights matrix (see constraints).</param>
        /// <param name="bias_constraint"> Constraint function applied to the bias vector (see constraints).</param>
        /// <param name="input_shape">nD tensor with shape: (batch_size, ..., input_dim). The most common situation would be a 2D input with shape (batch_size, input_dim).</param>
        public Dense(int units, int? input_dim = null, string activation= "", bool use_bias= true, StringOrInstance kernel_initializer= null, 
                    string bias_initializer= "zeros", StringOrInstance kernel_regularizer= null, string bias_regularizer= "", 
                    string activity_regularizer= "", string kernel_constraint= "", string bias_constraint= "", Shape input_shape = null)
        {
            this["units"] = units;
            this["input_dim"] = input_dim;
            this["activation"] = activation;
            this["use_bias"] = use_bias;
            this["kernel_initializer"] = kernel_initializer ?? "glorot_uniform";
            this["bias_initializer"] = bias_initializer;
            this["kernel_regularizer"] = kernel_regularizer;
            this["bias_regularizer"] = bias_regularizer;
            this["activity_regularizer"] = activity_regularizer;
            this["kernel_constraint"] = kernel_constraint;
            this["bias_constraint"] = bias_constraint;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.Dense;
            Init();
        }

    }

    /// <summary>
    /// Applies an activation function to an output.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Activation : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Activation"/> class.
        /// </summary>
        /// <param name="act">name of activation function to use (see: activations), or alternatively, a Theano or TensorFlow operation.</param>
        /// <param name="input_shape">Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.</param>
        public Activation(string act, Shape input_shape = null)
        {
            Parameters["activation"] = act;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.Activation;
            Init();
        }
    }

    /// <summary>
    /// Applies Dropout to the input.
    /// Dropout consists in randomly setting a fraction rate of input units to 0 at each update during training time, which helps prevent overfitting.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Dropout : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Dropout"/> class.
        /// </summary>
        /// <param name="rate">float between 0 and 1. Fraction of the input units to drop.</param>
        /// <param name="noise_shape">1D integer tensor representing the shape of the binary dropout mask that will be multiplied with the input. For instance, if your inputs have shape  (batch_size, timesteps, features) and you want the dropout mask to be the same for all timesteps, you can use noise_shape=(batch_size, 1, features).</param>
        /// <param name="seed">The random seed integer.</param>
        public Dropout(double rate, Shape noise_shape = null, int? seed = null)
        {
            Parameters["rate"] = rate;
            Parameters["noise_shape"] = noise_shape;
            Parameters["seed"] = seed;
            PyInstance = Instance.keras.layers.Dropout;
            Init();
        }
    }

    /// <summary>
    /// Flattens the input. Does not affect the batch size.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Flatten : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Flatten"/> class.
        /// </summary>
        /// <param name="data_format">A string, one of channels_last (default) or channels_first. The ordering of the dimensions in the inputs. The purpose of this argument is to preserve weight ordering when switching a model from one data format to another.  channels_last corresponds to inputs with shape  (batch, ..., channels) while channels_first corresponds to inputs with shape (batch, channels, ...). It defaults to the image_data_format value found in your Keras config file at ~/.keras/keras.json. If you never set it, then it will be "channels_last".</param>
        public Flatten(string data_format = "channels_last")
        {
            Parameters["data_format"] = data_format;
            PyInstance = Instance.keras.layers.Flatten;
            Init();
        }
    }

    /// <summary>
    /// Reshapes an output to a certain shape.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Reshape : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Reshape"/> class.
        /// </summary>
        /// <param name="target_shape">target shape. Tuple of integers. Does not include the batch axis.</param>
        /// <param name="input_shape">Arbitrary, although all dimensions in the input shaped must be fixed. Use the keyword argument input_shape (tuple of integers, does not include the batch axis) when using this layer as the first layer in a model.</param>
        public Reshape(Shape target_shape, Shape input_shape = null)
        {
            Parameters["target_shape"] = target_shape;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.Reshape;
            Init();
        }
    }

    /// <summary>
    /// Permutes the dimensions of the input according to a given pattern.    Useful for e.g.connecting RNNs and convnets together.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Permute : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Permute"/> class.
        /// </summary>
        /// <param name="dims">Tuple of integers. Permutation pattern, does not include the samples dimension. Indexing starts at 1. For instance, (2, 1) permutes the first and second dimension of the input.</param>
        /// <param name="input_shape">Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.</param>
        public Permute(int dims, Shape input_shape = null)
        {
            Parameters["dims"] = dims;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.Permute;
            Init();
        }
    }

    /// <summary>
    /// Repeats the input n times.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class RepeatVector : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RepeatVector"/> class.
        /// </summary>
        /// <param name="n">integer, repetition factor.</param>
        /// <param name="input_shape">2D tensor of shape (num_samples, features).</param>
        public RepeatVector(int n, Shape input_shape = null)
        {
            Parameters["n"] = n;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.RepeatVector;
            Init();
        }
    }

    /// <summary>
    /// Wraps arbitrary expression as a Layer object.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Lambda : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Lambda"/> class.
        /// </summary>
        /// <param name="function">The function to be evaluated. Takes input tensor or list of tensors as first argument.</param>
        /// <param name="output_shape">Expected output shape from function. Only relevant when using Theano. Can be a tuple or function. If a tuple, it only specifies the first dimension onward; sample dimension is assumed either the same as the input:  output_shape = (input_shape[0], ) + output_shape or, the input is None and the sample dimension is also None:  output_shape = (None, ) + output_shape If a function, it specifies the entire shape as a function of the input shape: output_shape = f(input_shape)</param>
        /// <param name="mask">Either None (indicating no masking) or a Tensor indicating the input mask for Embedding.</param>
        /// <param name="arguments">optional dictionary of keyword arguments to be passed to the function.</param>
        /// <param name="input_shape">Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.</param>
        public Lambda(object function, Shape output_shape = null, NDarray mask = null, Dictionary<string, object> arguments = null, Shape input_shape = null)
        {
            Parameters["function"] = function;
            Parameters["output_shape"] = output_shape;
            Parameters["mask"] = mask;
            Parameters["arguments"] = arguments;
            Parameters["input_shape"] = input_shape;

            PyInstance = Instance.keras.layers.Lambda;
            Init();
        }
    }

    /// <summary>
    /// Layer that applies an update to the cost function based input activity.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class ActivityRegularization : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ActivityRegularization"/> class.
        /// </summary>
        /// <param name="l1">L1 regularization factor (positive float).</param>
        /// <param name="l2"> L2 regularization factor (positive float).</param>
        /// <param name="input_shape">Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.</param>
        public ActivityRegularization(float l1= 0.0f, float l2= 0.0f, Shape input_shape = null)
        {
            Parameters["l1"] = l1;
            Parameters["l2"] = l2;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.ActivityRegularization;
            Init();
        }
    }

    /// <summary>
    /// Masks a sequence by using a mask value to skip timesteps.
    /// If all features for a given sample timestep are equal to mask_value, then the sample timestep will be masked(skipped) in all downstream layers(as long as they support masking).
    /// If any downstream layer does not support masking yet receives such an input mask, an exception will be raised.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class Masking : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Masking"/> class.
        /// </summary>
        /// <param name="mask_value">Either None or mask value to skip</param>
        public Masking(float mask_value = 0.0f)
        {
            Parameters["mask_value"] = mask_value;
            PyInstance = Instance.keras.layers.Masking;
            Init();
        }
    }

    /// <summary>
    /// Spatial 1D version of Dropout.
    /// This version performs the same function as Dropout, however it drops entire 1D feature maps instead of individual elements.If adjacent frames within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.In this case, SpatialDropout1D will help promote independence between feature maps and should be used instead.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class SpatialDropout1D : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SpatialDropout1D"/> class.
        /// </summary>
        /// <param name="rate">float between 0 and 1. Fraction of the input units to drop.</param>
        /// <param name="input_shape">3D tensor with shape: (samples, timesteps, channels)</param>
        public SpatialDropout1D(float rate, Shape input_shape = null)
        {
            Parameters["rate"] = rate;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.SpatialDropout1D;
            Init();
        }
    }

    /// <summary>
    /// Spatial 2D version of Dropout.
    /// This version performs the same function as Dropout, however it drops entire 2D feature maps instead of individual elements.If adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.In this case, SpatialDropout2D will help promote independence between feature maps and should be used instead.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class SpatialDropout2D : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SpatialDropout2D"/> class.
        /// </summary>
        /// <param name="rate">float between 0 and 1. Fraction of the input units to drop.</param>
        /// <param name="data_format"> 'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension (the depth) is at index 1, in 'channels_last' mode is it at index 3. It defaults to the image_data_format value found in your Keras config file at ~/.keras/keras.json. If you never set it, then it will be "channels_last".</param>
        /// <param name="input_shape">4D tensor with shape: (samples, channels, rows, cols) if data_format='channels_first' or 4D tensor with shape: (samples, rows, cols, channels) if data_format='channels_last'.</param>
        public SpatialDropout2D(float rate, string data_format = "", Shape input_shape = null)
        {
            Parameters["rate"] = rate;
            Parameters["input_shape"] = data_format;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.SpatialDropout2D;
            Init();
        }
    }

    /// <summary>
    /// Spatial 3D version of Dropout.
    /// This version performs the same function as Dropout, however it drops entire 3D feature maps instead of individual elements.If adjacent voxels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.In this case, SpatialDropout3D will help promote independence between feature maps and should be used instead.
    /// </summary>
    /// <seealso cref="Keras.Layers.BaseLayer" />
    public class SpatialDropout3D : BaseLayer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SpatialDropout3D"/> class.
        /// </summary>
        /// <param name="rate">float between 0 and 1. Fraction of the input units to drop.</param>
        /// <param name="data_format">'channels_first' or 'channels_last'. In 'channels_first' mode, the channels dimension (the depth) is at index 1, in 'channels_last' mode is it at index 4. It defaults to the image_data_format value found in your Keras config file at ~/.keras/keras.json. If you never set it, then it will be "channels_last".</param>
        /// <param name="input_shape">5D tensor with shape: (samples, channels, dim1, dim2, dim3) if data_format='channels_first' or 5D tensor with shape: (samples, dim1, dim2, dim3, channels) if data_format='channels_last'.</param>
        public SpatialDropout3D(float rate, string data_format = "", Shape input_shape = null)
        {
            Parameters["rate"] = rate;
            Parameters["input_shape"] = data_format;
            Parameters["input_shape"] = input_shape;
            PyInstance = Instance.keras.layers.SpatialDropout3D;
            Init();
        }
    }
}

